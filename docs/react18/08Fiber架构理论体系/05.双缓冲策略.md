# 什么是双缓冲策略
## 性能优化在 React 18 中的重要性

性能优化在 React 18 中具有非常重要的地位，性能优化在 React 18 中具有重要意义，它有助于提升用户体验、提高渲染效率、减小前端包体积等等。在不断优化性能的探索过程中，Fiber架构下采用了一种双缓冲策略来进行优化。那什么是双缓冲策略呢？

## 双缓冲策略
其实双缓冲策略主要用于计算机图形渲染，看这样一个图片：
```js
+----------------------+     +----------------------+ 
|      前缓冲区         |     |      后缓冲区          |
|                      |     |                      |
|   显示完整渲染的帧      |<----|   正在绘制的渲染帧      |
|                      |     |                      |
+----------------------+     +----------------------+ 
```
用户看见的是前缓冲区，正在准备的内容是后缓冲区，避免了用户看见的内容是渲染未完成的内容。
## Fiber架构中的双缓冲策略
在 React Fiber 中，每个 Fiber 节点都有一个对应的 alternate 节点，它们代表了同一个组件在不同阶段的状态。这种设计允许 React 在更新组件时在内存中构建和处理新的渲染树，类似于双缓冲策略中的后缓冲区。

更具体一点：

- 当前渲染树（类似于前缓冲区）：表示当前 UI 的状态，用户看到的就是当前渲染树所呈现的内容。
- 工作进程树（类似于后缓冲区）：在更新过程中，React 使用 alternate 节点构建一个新的渲染树。这个新的渲染树包含了更新后的组件状态。所有的更新操作都在这个新的渲染树中进行，就像双缓冲策略中的后缓冲区。
- 提交阶段（类似于前后缓冲区交换）：当工作进程树完成构建，React 会在提交阶段将其应用到 UI 上。这个过程类似于双缓冲策略中的前后缓冲区交换，当前渲染树和工作进程树交换角色，工作进程树成为新的当前渲染树，显示新的渲染状态。

通过这种方式，React Fiber 架构的 alternate 概念允许 React 在内存中构建和处理新的渲染树，避免 UI 的不必要更新和卡顿现象，提高渲染性能和用户体验。这与双缓冲策略在图形渲染中的作用有相似之处。

更具体一点，举个例子：
```js
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increase</button>
    </div>
  );
}

export default Counter;

```
当用户点击 "Increase" 按钮时，计数器的值会增加。在 React 内部，以下过程将发生：

- React 会创建一个新的工作进程树（类似于后缓冲区），其中包含更新后的计数器状态。这个新的渲染树在内存中构建，不会立即反映在 UI 上。
- 同时，当前渲染树（类似于前缓冲区）继续保持现有的 UI 状态，用户仍然可以看到当前的计数值。
- 在工作进程树构建完成后，React 会将其应用到 UI（类似于前后缓冲区交换），此时用户将看到更新后的计数值。

这种双缓存技术使得 React 能够在执行渲染任务时更加高效，因为它可以在新的 Fiber 树上进行更改，同时保持旧的 Fiber 树不变。一旦新的 Fiber 树准备好被提交，React 就会在两棵树之间进行切换，从而实现高效的更新。
