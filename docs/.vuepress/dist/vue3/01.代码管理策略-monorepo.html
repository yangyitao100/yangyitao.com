<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.53">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?3ada78bd736d6c32ac7d2e900e4e3d9d";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();</script><link rel="icon" href="/images/developer.jpeg"><title>01.代码管理策略-monorepo | 杨艺韬的官方网站</title><meta name="description" content="杨艺韬的官方网站, 杨艺韬, Adam Yang, react18, React, vue3, 源码, 前端">
    <link rel="preload" href="/assets/style.512c328e.css" as="style" /><link rel="stylesheet" href="/assets/style.512c328e.css" />
    <link rel="modulepreload" href="/assets/app.4326c516.js"><link rel="modulepreload" href="/assets/01.代码管理策略-monorepo.html.c5fcbeff.js"><link rel="modulepreload" href="/assets/01.代码管理策略-monorepo.html.d2d577b6.js"><link rel="prefetch" href="/assets/index.html.295e9bc2.js" as="script" /><link rel="prefetch" href="/assets/index.html.bba26bdf.js" as="script" /><link rel="prefetch" href="/assets/01.乾坤的Js隔离机制原理剖析（快照沙箱、两种代理沙箱）.html.58370679.js" as="script" /><link rel="prefetch" href="/assets/02.乾坤的微应用加载流程分析(从微应用的注册到loadApp方法内部实现).html.0d8c0575.js" as="script" /><link rel="prefetch" href="/assets/03.乾坤的沙箱容器分析（Js沙箱机制建立后的具体应用）.html.3d13d503.js" as="script" /><link rel="prefetch" href="/assets/04.乾坤的资源加载机制(import-html-entry的内部实现).html.92a85075.js" as="script" /><link rel="prefetch" href="/assets/05.乾坤loadMicroApp方法实现以及数据通信机制分析.html.e159d950.js" as="script" /><link rel="prefetch" href="/assets/06.single-spa的注册机制.html.1e86d052.js" as="script" /><link rel="prefetch" href="/assets/07.对single-spa的路由管理及微应用状态管理的分析.html.850dc54e.js" as="script" /><link rel="prefetch" href="/assets/08.single-spa中的reroute函数.html.dc26bab2.js" as="script" /><link rel="prefetch" href="/assets/index.html.68f323cd.js" as="script" /><link rel="prefetch" href="/assets/index.html.f051536c.js" as="script" /><link rel="prefetch" href="/assets/02.项目构建流程和源码调试方法.html.33eb6ed9.js" as="script" /><link rel="prefetch" href="/assets/03.Vue3响应式核心原理.html.1cd6ecba.js" as="script" /><link rel="prefetch" href="/assets/04.Vue3响应式系统源码实现1.html.90173631.js" as="script" /><link rel="prefetch" href="/assets/05.Vue3响应式系统源码实现2.html.c18f024a.js" as="script" /><link rel="prefetch" href="/assets/06.reactive、ref相关api源码实现.html.f1ada482.js" as="script" /><link rel="prefetch" href="/assets/07.故事要从createApp讲起.html.6dae10d0.js" as="script" /><link rel="prefetch" href="/assets/08.虚拟Node到真实Node的路其实很长.html.34502cd7.js" as="script" /><link rel="prefetch" href="/assets/09.组件渲染和更新流程.html.e67daf6b.js" as="script" /><link rel="prefetch" href="/assets/10.名动江湖的diff算法.html.844ae1a8.js" as="script" /><link rel="prefetch" href="/assets/11.编译优化之Block Tree 与 PatchFlags.html.5736a5a6.js" as="script" /><link rel="prefetch" href="/assets/12.编译过程介绍及分析模版AST的生成过程.html.5647b4a3.js" as="script" /><link rel="prefetch" href="/assets/13.从AST到render函数（transform与代码生成）.html.e51e34f5.js" as="script" /><link rel="prefetch" href="/assets/index.html.e7f880cd.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.501e9305.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.83c991ec.js" as="script" /><link rel="prefetch" href="/assets/02.树立正确的源码观.html.fb13da14.js" as="script" /><link rel="prefetch" href="/assets/03.React是什么.html.8ab59fb0.js" as="script" /><link rel="prefetch" href="/assets/04.React架构演进过程.html.393e1a6f.js" as="script" /><link rel="prefetch" href="/assets/05.树立数据结构与算法的意识.html.ca13f42a.js" as="script" /><link rel="prefetch" href="/assets/06.树立用原子视角看问题的意识.html.d0de50fb.js" as="script" /><link rel="prefetch" href="/assets/07.React18源码学习方法.html.4c3ab811.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.22395461.js" as="script" /><link rel="prefetch" href="/assets/02.环境准备.html.21cf1d16.js" as="script" /><link rel="prefetch" href="/assets/03.虚拟DOM与真实DOM的实况对比.html.559bb4a0.js" as="script" /><link rel="prefetch" href="/assets/04.JSX相关概念和原理.html.06fcc809.js" as="script" /><link rel="prefetch" href="/assets/05.React和ReactDOM职责划分.html.33c9e328.js" as="script" /><link rel="prefetch" href="/assets/06.createElement代码实现.html.0456a944.js" as="script" /><link rel="prefetch" href="/assets/07.实现 render、mount 和 createDOM进行初次渲染.html.41543d69.js" as="script" /><link rel="prefetch" href="/assets/08.实现函数setPropsForDOM为DOM设置属性.html.37d884ac.js" as="script" /><link rel="prefetch" href="/assets/09.调试初始化渲染过程.html.e76fd42c.js" as="script" /><link rel="prefetch" href="/assets/10.思考题与解答.html.6ed61faa.js" as="script" /><link rel="prefetch" href="/assets/11.本章小结.html.f91c6139.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.b5f266a9.js" as="script" /><link rel="prefetch" href="/assets/02.函数组件与类组件介绍.html.2c4a5a13.js" as="script" /><link rel="prefetch" href="/assets/03.实现函数组件基础功能.html.b9da3afc.js" as="script" /><link rel="prefetch" href="/assets/04.实现类组件基础功能.html.69a246c3.js" as="script" /><link rel="prefetch" href="/assets/05.类组件的更新机制分析.html.19428106.js" as="script" /><link rel="prefetch" href="/assets/06.实现类组件的setState方法.html.8e46262c.js" as="script" /><link rel="prefetch" href="/assets/07.事件合成机制原理分析.html.830bf124.js" as="script" /><link rel="prefetch" href="/assets/08.事件合成机制的简单实现.html.37ae6cb4.js" as="script" /><link rel="prefetch" href="/assets/09.ref的原理分析.html.64825db1.js" as="script" /><link rel="prefetch" href="/assets/10.类组件的ref源码实现.html.2d266ccd.js" as="script" /><link rel="prefetch" href="/assets/11.引入forwardRef的底层逻辑.html.80288dc9.js" as="script" /><link rel="prefetch" href="/assets/12.实现forwardRef为函数组件提供ref的能力.html.7b832146.js" as="script" /><link rel="prefetch" href="/assets/13.调试函数组件与类组件相关代码.html.c5318fc6.js" as="script" /><link rel="prefetch" href="/assets/14.思考题与解答.html.e29d1ced.js" as="script" /><link rel="prefetch" href="/assets/15.本章小结.html.0a37d66d.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.5c56ed55.js" as="script" /><link rel="prefetch" href="/assets/02.React DOM DIFF原理.html.c06333b9.js" as="script" /><link rel="prefetch" href="/assets/03.React DOM DIFF算法源码实现.html.a92af391.js" as="script" /><link rel="prefetch" href="/assets/04.调试DOM DIFF算法.html.a39f906a.js" as="script" /><link rel="prefetch" href="/assets/05.思考题及解答.html.a964dca8.js" as="script" /><link rel="prefetch" href="/assets/06.本章小结.html.9f3b6ec7.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.0109b860.js" as="script" /><link rel="prefetch" href="/assets/02.生命周期的内涵.html.fede1a71.js" as="script" /><link rel="prefetch" href="/assets/03.生命周期图观察.html.974682b4.js" as="script" /><link rel="prefetch" href="/assets/04.常用生命周期函数应用案例.html.58f4fa8d.js" as="script" /><link rel="prefetch" href="/assets/05.常用生命周期函数源码实现.html.f2204171.js" as="script" /><link rel="prefetch" href="/assets/06.shouldComponentUpdate案例.html.dcef12d5.js" as="script" /><link rel="prefetch" href="/assets/07.shouldComponentUpdate实现.html.3755b6c4.js" as="script" /><link rel="prefetch" href="/assets/08.getDeriveStateFromProp案例.html.8a1252bb.js" as="script" /><link rel="prefetch" href="/assets/09.getDeriveStateFromProps源码实现.html.9db4f077.js" as="script" /><link rel="prefetch" href="/assets/10.getSnapshotBeforeUpdate应用案例.html.071a1bd9.js" as="script" /><link rel="prefetch" href="/assets/11.getSnapshotBeforeUpdate源码实现.html.cfa8ce6c.js" as="script" /><link rel="prefetch" href="/assets/12.生命周期相关代码调试.html.17603927.js" as="script" /><link rel="prefetch" href="/assets/13.思考题及解答.html.a7f21ab0.js" as="script" /><link rel="prefetch" href="/assets/14.本章小结.html.bcba6af3.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.ad1b676f.js" as="script" /><link rel="prefetch" href="/assets/02.PureComponent应用案例.html.29c8f991.js" as="script" /><link rel="prefetch" href="/assets/03.PureComponent源码实现.html.74ae40b9.js" as="script" /><link rel="prefetch" href="/assets/04.memo应用案例.html.3ef4e9fe.js" as="script" /><link rel="prefetch" href="/assets/05.memo源码实现.html.9486e679.js" as="script" /><link rel="prefetch" href="/assets/06.调试PureComponent及memo相关的代码.html.b627d26b.js" as="script" /><link rel="prefetch" href="/assets/07.思考题及解答.html.30aff959.js" as="script" /><link rel="prefetch" href="/assets/08.本章小结.html.ed797777.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.d46d0437.js" as="script" /><link rel="prefetch" href="/assets/02.为什么需要Fiber架构.html.d180591d.js" as="script" /><link rel="prefetch" href="/assets/03.Fiber架构是什么.html.54fe6f6c.js" as="script" /><link rel="prefetch" href="/assets/04.Fiber是什么.html.f784bba3.js" as="script" /><link rel="prefetch" href="/assets/05.双缓冲策略.html.2e651b1f.js" as="script" /><link rel="prefetch" href="/assets/06.什么是工作循环.html.59fe3cee.js" as="script" /><link rel="prefetch" href="/assets/07.什么是并发模式.html.7e908706.js" as="script" /><link rel="prefetch" href="/assets/08.思考题及解答.html.2cb70c22.js" as="script" /><link rel="prefetch" href="/assets/09.小结.html.d925967a.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.c871d2e2.js" as="script" /><link rel="prefetch" href="/assets/02.环境准备.html.6ea9422d.js" as="script" /><link rel="prefetch" href="/assets/03.jsx代码实现.html.2d6a50ab.js" as="script" /><link rel="prefetch" href="/assets/04.createRoot.html.2614bca8.js" as="script" /><link rel="prefetch" href="/assets/05.render函数的阶段划分.html.f47defce.js" as="script" /><link rel="prefetch" href="/assets/06.beginWork.html.77aa0a61.js" as="script" /><link rel="prefetch" href="/assets/07.completeWork.html.8e252c3c.js" as="script" /><link rel="prefetch" href="/assets/08.commitWork.html.41fa9bde.js" as="script" /><link rel="prefetch" href="/assets/09.代码调试.html.2c9c92bc.js" as="script" /><link rel="prefetch" href="/assets/10.函数组件的初始化.html.013cf3e2.js" as="script" /><link rel="prefetch" href="/assets/11.思考题.html.f6bb4986.js" as="script" /><link rel="prefetch" href="/assets/12.小结.html.2bb91b5e.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.93f955bf.js" as="script" /><link rel="prefetch" href="/assets/02.Hooks存在的意义.html.99f853db.js" as="script" /><link rel="prefetch" href="/assets/03.useState应用案例.html.7a27c44c.js" as="script" /><link rel="prefetch" href="/assets/04.useState源码实现.html.b6770829.js" as="script" /><link rel="prefetch" href="/assets/05.useReducer应用案例.html.18c8d25e.js" as="script" /><link rel="prefetch" href="/assets/06.useReducer源码实现.html.e02afb3e.js" as="script" /><link rel="prefetch" href="/assets/07.useEffect及useLayoutEffect应用案例.html.6d954f40.js" as="script" /><link rel="prefetch" href="/assets/08.useEffect及useLayoutEffect源码实现.html.c7da98a1.js" as="script" /><link rel="prefetch" href="/assets/09.useRef应用案例及源码实现.html.83fab4fd.js" as="script" /><link rel="prefetch" href="/assets/10.useImperativeHandle应用案例及源码实现.html.b6a790ea.js" as="script" /><link rel="prefetch" href="/assets/11.useMemo及useCallback应用案例.html.01058c5f.js" as="script" /><link rel="prefetch" href="/assets/12.useMemo及useCallback源码实现.html.6fdcbe57.js" as="script" /><link rel="prefetch" href="/assets/13.Hooks相关源码调试.html.87195cff.js" as="script" /><link rel="prefetch" href="/assets/14.思考题及解答.html.1bd5bf45.js" as="script" /><link rel="prefetch" href="/assets/15.本章小结.html.d89b82e8.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.e878169d.js" as="script" /><link rel="prefetch" href="/assets/02.domdiff思路分析.html.ff56b49e.js" as="script" /><link rel="prefetch" href="/assets/03.单节点domdiff.html.b087761c.js" as="script" /><link rel="prefetch" href="/assets/04.多节点domdiff.html.44e670a7.js" as="script" /><link rel="prefetch" href="/assets/05.思考题.html.f1f6116d.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.4ec62a06.js" as="script" /><link rel="prefetch" href="/assets/02.事件系统实现思路分析.html.8d98d6cb.js" as="script" /><link rel="prefetch" href="/assets/03.事件名注册.html.256c44ef.js" as="script" /><link rel="prefetch" href="/assets/04.注册监听事件.html.32e87da2.js" as="script" /><link rel="prefetch" href="/assets/05.派发事件的主要逻辑.html.cd6fd3b2.js" as="script" /><link rel="prefetch" href="/assets/06.收集注册的函数.html.08594967.js" as="script" /><link rel="prefetch" href="/assets/07.合成事件.html.67c4f89b.js" as="script" /><link rel="prefetch" href="/assets/08.注册事件的回调.html.be697f66.js" as="script" /><link rel="prefetch" href="/assets/09.代码调试.html.791e76ea.js" as="script" /><link rel="prefetch" href="/assets/10.思考题.html.17a524d5.js" as="script" /><link rel="prefetch" href="/assets/11.小结.html.7f324403.js" as="script" /><link rel="prefetch" href="/assets/introduction.html.6859cccd.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.0ada0da1.js" as="script" /><link rel="prefetch" href="/assets/02.useReducer挂载.html.9199073b.js" as="script" /><link rel="prefetch" href="/assets/03.useReducer触发更新.html.74a19eee.js" as="script" /><link rel="prefetch" href="/assets/04.useReducer更新渲染1.html.9fc04de4.js" as="script" /><link rel="prefetch" href="/assets/05.useReducer更新渲染2.html.4bc6a7ed.js" as="script" /><link rel="prefetch" href="/assets/06.useState源码实现.html.7865f484.js" as="script" /><link rel="prefetch" href="/assets/07.useEffect挂载实现.html.d35c82a4.js" as="script" /><link rel="prefetch" href="/assets/08.useEffect更新实现.html.72b52a42.js" as="script" /><link rel="prefetch" href="/assets/09.useLayoutEffect源码实现.html.13881dac.js" as="script" /><link rel="prefetch" href="/assets/10.代码调试.html.da8e9233.js" as="script" /><link rel="prefetch" href="/assets/11.思考题.html.5cec2d5b.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.eca6cfe8.js" as="script" /><link rel="prefetch" href="/assets/02.二进制基础计算.html.bc129849.js" as="script" /><link rel="prefetch" href="/assets/03.最小堆算法.html.3f81952c.js" as="script" /><link rel="prefetch" href="/assets/04.React18的优先级体系.html.866eda4c.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.d8648cd3.js" as="script" /><link rel="prefetch" href="/assets/02.调度核心逻辑.html.0ca7ccee.js" as="script" /><link rel="prefetch" href="/assets/03.任务优先级与事件优先级.html.200dfaed.js" as="script" /><link rel="prefetch" href="/assets/04.lane模型下的更新队列.html.56c76bd7.js" as="script" /><link rel="prefetch" href="/assets/05.加入优先级的初始化渲染.html.7d586f05.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.c07c856d.js" as="script" /><link rel="prefetch" href="/assets/02.同步渲染.html.2303e51a.js" as="script" /><link rel="prefetch" href="/assets/03.并发渲染.html.b2ddab47.js" as="script" /><link rel="prefetch" href="/assets/04.思考题.html.a1920c62.js" as="script" /><link rel="prefetch" href="/assets/404.html.c3e557d0.js" as="script" /><link rel="prefetch" href="/assets/index.html.5809927a.js" as="script" /><link rel="prefetch" href="/assets/index.html.818335f7.js" as="script" /><link rel="prefetch" href="/assets/01.乾坤的Js隔离机制原理剖析（快照沙箱、两种代理沙箱）.html.56a6096c.js" as="script" /><link rel="prefetch" href="/assets/02.乾坤的微应用加载流程分析(从微应用的注册到loadApp方法内部实现).html.bbdf3644.js" as="script" /><link rel="prefetch" href="/assets/03.乾坤的沙箱容器分析（Js沙箱机制建立后的具体应用）.html.0e491c75.js" as="script" /><link rel="prefetch" href="/assets/04.乾坤的资源加载机制(import-html-entry的内部实现).html.82a96f5d.js" as="script" /><link rel="prefetch" href="/assets/05.乾坤loadMicroApp方法实现以及数据通信机制分析.html.b1bafd18.js" as="script" /><link rel="prefetch" href="/assets/06.single-spa的注册机制.html.baf5d62f.js" as="script" /><link rel="prefetch" href="/assets/07.对single-spa的路由管理及微应用状态管理的分析.html.89b6c65a.js" as="script" /><link rel="prefetch" href="/assets/08.single-spa中的reroute函数.html.15aa071a.js" as="script" /><link rel="prefetch" href="/assets/index.html.7cd52998.js" as="script" /><link rel="prefetch" href="/assets/index.html.ed1d34b8.js" as="script" /><link rel="prefetch" href="/assets/02.项目构建流程和源码调试方法.html.836f1967.js" as="script" /><link rel="prefetch" href="/assets/03.Vue3响应式核心原理.html.c75e241e.js" as="script" /><link rel="prefetch" href="/assets/04.Vue3响应式系统源码实现1.html.9ad588ce.js" as="script" /><link rel="prefetch" href="/assets/05.Vue3响应式系统源码实现2.html.a21938e4.js" as="script" /><link rel="prefetch" href="/assets/06.reactive、ref相关api源码实现.html.3c47782a.js" as="script" /><link rel="prefetch" href="/assets/07.故事要从createApp讲起.html.8ba91423.js" as="script" /><link rel="prefetch" href="/assets/08.虚拟Node到真实Node的路其实很长.html.e5eec66f.js" as="script" /><link rel="prefetch" href="/assets/09.组件渲染和更新流程.html.052dbb9e.js" as="script" /><link rel="prefetch" href="/assets/10.名动江湖的diff算法.html.c93753c1.js" as="script" /><link rel="prefetch" href="/assets/11.编译优化之Block Tree 与 PatchFlags.html.ada5ebaf.js" as="script" /><link rel="prefetch" href="/assets/12.编译过程介绍及分析模版AST的生成过程.html.bde864ec.js" as="script" /><link rel="prefetch" href="/assets/13.从AST到render函数（transform与代码生成）.html.c1de5736.js" as="script" /><link rel="prefetch" href="/assets/index.html.48e2d3b7.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.ed73c41b.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.3ff4f2bc.js" as="script" /><link rel="prefetch" href="/assets/02.树立正确的源码观.html.3ad5aff3.js" as="script" /><link rel="prefetch" href="/assets/03.React是什么.html.2c830885.js" as="script" /><link rel="prefetch" href="/assets/04.React架构演进过程.html.14ed331c.js" as="script" /><link rel="prefetch" href="/assets/05.树立数据结构与算法的意识.html.f61c9876.js" as="script" /><link rel="prefetch" href="/assets/06.树立用原子视角看问题的意识.html.539a71e4.js" as="script" /><link rel="prefetch" href="/assets/07.React18源码学习方法.html.b6bd9ac7.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.7c718749.js" as="script" /><link rel="prefetch" href="/assets/02.环境准备.html.3ad0cf8f.js" as="script" /><link rel="prefetch" href="/assets/03.虚拟DOM与真实DOM的实况对比.html.456208b3.js" as="script" /><link rel="prefetch" href="/assets/04.JSX相关概念和原理.html.5667b6d3.js" as="script" /><link rel="prefetch" href="/assets/05.React和ReactDOM职责划分.html.c1efe0a0.js" as="script" /><link rel="prefetch" href="/assets/06.createElement代码实现.html.0dd886ab.js" as="script" /><link rel="prefetch" href="/assets/07.实现 render、mount 和 createDOM进行初次渲染.html.2ae88d41.js" as="script" /><link rel="prefetch" href="/assets/08.实现函数setPropsForDOM为DOM设置属性.html.4367b30c.js" as="script" /><link rel="prefetch" href="/assets/09.调试初始化渲染过程.html.cabdf266.js" as="script" /><link rel="prefetch" href="/assets/10.思考题与解答.html.8fb79fc2.js" as="script" /><link rel="prefetch" href="/assets/11.本章小结.html.e453ef2f.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.b46314c8.js" as="script" /><link rel="prefetch" href="/assets/02.函数组件与类组件介绍.html.08a5d058.js" as="script" /><link rel="prefetch" href="/assets/03.实现函数组件基础功能.html.e7cf6edc.js" as="script" /><link rel="prefetch" href="/assets/04.实现类组件基础功能.html.57bf5bf6.js" as="script" /><link rel="prefetch" href="/assets/05.类组件的更新机制分析.html.8ece9f63.js" as="script" /><link rel="prefetch" href="/assets/06.实现类组件的setState方法.html.a9d36291.js" as="script" /><link rel="prefetch" href="/assets/07.事件合成机制原理分析.html.faf7c593.js" as="script" /><link rel="prefetch" href="/assets/08.事件合成机制的简单实现.html.fa0ec7cb.js" as="script" /><link rel="prefetch" href="/assets/09.ref的原理分析.html.a6088b21.js" as="script" /><link rel="prefetch" href="/assets/10.类组件的ref源码实现.html.d3f4ee7e.js" as="script" /><link rel="prefetch" href="/assets/11.引入forwardRef的底层逻辑.html.199e94e6.js" as="script" /><link rel="prefetch" href="/assets/12.实现forwardRef为函数组件提供ref的能力.html.97378e9f.js" as="script" /><link rel="prefetch" href="/assets/13.调试函数组件与类组件相关代码.html.ef09923a.js" as="script" /><link rel="prefetch" href="/assets/14.思考题与解答.html.687e1914.js" as="script" /><link rel="prefetch" href="/assets/15.本章小结.html.66acd7bc.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.b986bbee.js" as="script" /><link rel="prefetch" href="/assets/02.React DOM DIFF原理.html.d2b54ecc.js" as="script" /><link rel="prefetch" href="/assets/03.React DOM DIFF算法源码实现.html.471d2fe8.js" as="script" /><link rel="prefetch" href="/assets/04.调试DOM DIFF算法.html.1089e4a4.js" as="script" /><link rel="prefetch" href="/assets/05.思考题及解答.html.d32eaa1c.js" as="script" /><link rel="prefetch" href="/assets/06.本章小结.html.adff0000.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.de646e55.js" as="script" /><link rel="prefetch" href="/assets/02.生命周期的内涵.html.45bec316.js" as="script" /><link rel="prefetch" href="/assets/03.生命周期图观察.html.1afe06ae.js" as="script" /><link rel="prefetch" href="/assets/04.常用生命周期函数应用案例.html.5efe0c82.js" as="script" /><link rel="prefetch" href="/assets/05.常用生命周期函数源码实现.html.4ed64516.js" as="script" /><link rel="prefetch" href="/assets/06.shouldComponentUpdate案例.html.76348298.js" as="script" /><link rel="prefetch" href="/assets/07.shouldComponentUpdate实现.html.218c6ae0.js" as="script" /><link rel="prefetch" href="/assets/08.getDeriveStateFromProp案例.html.53861331.js" as="script" /><link rel="prefetch" href="/assets/09.getDeriveStateFromProps源码实现.html.72751863.js" as="script" /><link rel="prefetch" href="/assets/10.getSnapshotBeforeUpdate应用案例.html.02173565.js" as="script" /><link rel="prefetch" href="/assets/11.getSnapshotBeforeUpdate源码实现.html.7a0fdca5.js" as="script" /><link rel="prefetch" href="/assets/12.生命周期相关代码调试.html.ebab5b56.js" as="script" /><link rel="prefetch" href="/assets/13.思考题及解答.html.487470cf.js" as="script" /><link rel="prefetch" href="/assets/14.本章小结.html.9228b1e5.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.7b1c3de7.js" as="script" /><link rel="prefetch" href="/assets/02.PureComponent应用案例.html.c49cde12.js" as="script" /><link rel="prefetch" href="/assets/03.PureComponent源码实现.html.556ab389.js" as="script" /><link rel="prefetch" href="/assets/04.memo应用案例.html.60d46c64.js" as="script" /><link rel="prefetch" href="/assets/05.memo源码实现.html.768a9b7d.js" as="script" /><link rel="prefetch" href="/assets/06.调试PureComponent及memo相关的代码.html.6e3b9faa.js" as="script" /><link rel="prefetch" href="/assets/07.思考题及解答.html.268662cc.js" as="script" /><link rel="prefetch" href="/assets/08.本章小结.html.5112c9f3.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.e06730ce.js" as="script" /><link rel="prefetch" href="/assets/02.为什么需要Fiber架构.html.d236354e.js" as="script" /><link rel="prefetch" href="/assets/03.Fiber架构是什么.html.e02ed7ed.js" as="script" /><link rel="prefetch" href="/assets/04.Fiber是什么.html.84036ef4.js" as="script" /><link rel="prefetch" href="/assets/05.双缓冲策略.html.39aa63a3.js" as="script" /><link rel="prefetch" href="/assets/06.什么是工作循环.html.79650e92.js" as="script" /><link rel="prefetch" href="/assets/07.什么是并发模式.html.02c4e877.js" as="script" /><link rel="prefetch" href="/assets/08.思考题及解答.html.cdb8f61b.js" as="script" /><link rel="prefetch" href="/assets/09.小结.html.940c2e84.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.7bb307c7.js" as="script" /><link rel="prefetch" href="/assets/02.环境准备.html.0f490d5f.js" as="script" /><link rel="prefetch" href="/assets/03.jsx代码实现.html.f216a016.js" as="script" /><link rel="prefetch" href="/assets/04.createRoot.html.526f688c.js" as="script" /><link rel="prefetch" href="/assets/05.render函数的阶段划分.html.2dfce625.js" as="script" /><link rel="prefetch" href="/assets/06.beginWork.html.f1365a6c.js" as="script" /><link rel="prefetch" href="/assets/07.completeWork.html.8b84f8b0.js" as="script" /><link rel="prefetch" href="/assets/08.commitWork.html.90d30329.js" as="script" /><link rel="prefetch" href="/assets/09.代码调试.html.04474b2d.js" as="script" /><link rel="prefetch" href="/assets/10.函数组件的初始化.html.8b1b94b0.js" as="script" /><link rel="prefetch" href="/assets/11.思考题.html.5b4ebea4.js" as="script" /><link rel="prefetch" href="/assets/12.小结.html.f2036d0f.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.b3f1a3d6.js" as="script" /><link rel="prefetch" href="/assets/02.Hooks存在的意义.html.9bc4b1fe.js" as="script" /><link rel="prefetch" href="/assets/03.useState应用案例.html.12899923.js" as="script" /><link rel="prefetch" href="/assets/04.useState源码实现.html.422599ef.js" as="script" /><link rel="prefetch" href="/assets/05.useReducer应用案例.html.b2a5a758.js" as="script" /><link rel="prefetch" href="/assets/06.useReducer源码实现.html.c9233194.js" as="script" /><link rel="prefetch" href="/assets/07.useEffect及useLayoutEffect应用案例.html.5bf5cf94.js" as="script" /><link rel="prefetch" href="/assets/08.useEffect及useLayoutEffect源码实现.html.a3727575.js" as="script" /><link rel="prefetch" href="/assets/09.useRef应用案例及源码实现.html.5b58699e.js" as="script" /><link rel="prefetch" href="/assets/10.useImperativeHandle应用案例及源码实现.html.ee13bdad.js" as="script" /><link rel="prefetch" href="/assets/11.useMemo及useCallback应用案例.html.d4a35172.js" as="script" /><link rel="prefetch" href="/assets/12.useMemo及useCallback源码实现.html.085a618d.js" as="script" /><link rel="prefetch" href="/assets/13.Hooks相关源码调试.html.64665632.js" as="script" /><link rel="prefetch" href="/assets/14.思考题及解答.html.f23866c3.js" as="script" /><link rel="prefetch" href="/assets/15.本章小结.html.4b2ead4c.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.d411278c.js" as="script" /><link rel="prefetch" href="/assets/02.domdiff思路分析.html.4669fd92.js" as="script" /><link rel="prefetch" href="/assets/03.单节点domdiff.html.e3407126.js" as="script" /><link rel="prefetch" href="/assets/04.多节点domdiff.html.6c626f62.js" as="script" /><link rel="prefetch" href="/assets/05.思考题.html.78bfcd6f.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.5d454761.js" as="script" /><link rel="prefetch" href="/assets/02.事件系统实现思路分析.html.746e5e68.js" as="script" /><link rel="prefetch" href="/assets/03.事件名注册.html.40d88da1.js" as="script" /><link rel="prefetch" href="/assets/04.注册监听事件.html.34fb2d93.js" as="script" /><link rel="prefetch" href="/assets/05.派发事件的主要逻辑.html.e08d6173.js" as="script" /><link rel="prefetch" href="/assets/06.收集注册的函数.html.eb54e160.js" as="script" /><link rel="prefetch" href="/assets/07.合成事件.html.87f3c977.js" as="script" /><link rel="prefetch" href="/assets/08.注册事件的回调.html.96e458a1.js" as="script" /><link rel="prefetch" href="/assets/09.代码调试.html.e2497778.js" as="script" /><link rel="prefetch" href="/assets/10.思考题.html.4965f910.js" as="script" /><link rel="prefetch" href="/assets/11.小结.html.b738d155.js" as="script" /><link rel="prefetch" href="/assets/introduction.html.7fd1a303.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.c1d435e3.js" as="script" /><link rel="prefetch" href="/assets/02.useReducer挂载.html.f1eadb29.js" as="script" /><link rel="prefetch" href="/assets/03.useReducer触发更新.html.70f4d083.js" as="script" /><link rel="prefetch" href="/assets/04.useReducer更新渲染1.html.ab189770.js" as="script" /><link rel="prefetch" href="/assets/05.useReducer更新渲染2.html.e083fcdd.js" as="script" /><link rel="prefetch" href="/assets/06.useState源码实现.html.0345a94e.js" as="script" /><link rel="prefetch" href="/assets/07.useEffect挂载实现.html.02eb42b0.js" as="script" /><link rel="prefetch" href="/assets/08.useEffect更新实现.html.29d598dd.js" as="script" /><link rel="prefetch" href="/assets/09.useLayoutEffect源码实现.html.de67c467.js" as="script" /><link rel="prefetch" href="/assets/10.代码调试.html.dd6bf0d8.js" as="script" /><link rel="prefetch" href="/assets/11.思考题.html.6694fdb4.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.101401a3.js" as="script" /><link rel="prefetch" href="/assets/02.二进制基础计算.html.1d446ed1.js" as="script" /><link rel="prefetch" href="/assets/03.最小堆算法.html.4bb00463.js" as="script" /><link rel="prefetch" href="/assets/04.React18的优先级体系.html.05ff15a1.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.82e16471.js" as="script" /><link rel="prefetch" href="/assets/02.调度核心逻辑.html.10dab326.js" as="script" /><link rel="prefetch" href="/assets/03.任务优先级与事件优先级.html.fee935da.js" as="script" /><link rel="prefetch" href="/assets/04.lane模型下的更新队列.html.de2f6fa3.js" as="script" /><link rel="prefetch" href="/assets/05.加入优先级的初始化渲染.html.6987ac7b.js" as="script" /><link rel="prefetch" href="/assets/01.本章介绍.html.0d9cb3c9.js" as="script" /><link rel="prefetch" href="/assets/02.同步渲染.html.f830d442.js" as="script" /><link rel="prefetch" href="/assets/03.并发渲染.html.6c7509bc.js" as="script" /><link rel="prefetch" href="/assets/04.思考题.html.9f9ac0cc.js" as="script" /><link rel="prefetch" href="/assets/404.html.30043dcc.js" as="script" /><link rel="prefetch" href="/assets/giscus.06b5451c.js" as="script" />
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="切换侧边栏" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><img class="logo" src="/images/developer.jpeg" alt="杨艺韬的官方网站"><span class="site-name can-hide">杨艺韬的官方网站</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/react18/" class="" aria-label="手写React源码"><!--[--><!--]--> 手写React源码 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vue3/" class="router-link-active" aria-label="Vue3源码剖析"><!--[--><!--]--> Vue3源码剖析 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/microfe/" class="" aria-label="微前端源码剖析"><!--[--><!--]--> 微前端源码剖析 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://www.github.com/yangyitao100" rel="noopener noreferrer" target="_blank" aria-label="github"><!--[--><!--]--> github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><!----><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/react18/" class="" aria-label="手写React源码"><!--[--><!--]--> 手写React源码 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vue3/" class="router-link-active" aria-label="Vue3源码剖析"><!--[--><!--]--> Vue3源码剖析 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/microfe/" class="" aria-label="微前端源码剖析"><!--[--><!--]--> 微前端源码剖析 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://www.github.com/yangyitao100" rel="noopener noreferrer" target="_blank" aria-label="github"><!--[--><!--]--> github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="/vue3/README.md" class="sidebar-item sidebar-heading active" aria-label="Vue3源码剖析"><!--[--><!--]--> Vue3源码剖析 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vue3/01.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5-monorepo.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="01.代码管理策略-monorepo"><!--[--><!--]--> 01.代码管理策略-monorepo <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vue3/01.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5-monorepo.html#monorepo是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="monorepo是什么"><!--[--><!--]--> monorepo是什么 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue3/01.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5-monorepo.html#monorepo有什么优势" class="router-link-active router-link-exact-active sidebar-item" aria-label="monorepo有什么优势"><!--[--><!--]--> monorepo有什么优势 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vue3/01.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5-monorepo.html#优势1-重用代码更加容易" class="router-link-active router-link-exact-active sidebar-item" aria-label="优势1:重用代码更加容易"><!--[--><!--]--> 优势1:重用代码更加容易 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue3/01.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5-monorepo.html#优势2-简化依赖管理" class="router-link-active router-link-exact-active sidebar-item" aria-label="优势2:简化依赖管理"><!--[--><!--]--> 优势2:简化依赖管理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue3/01.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5-monorepo.html#优势3-提交记录原子化" class="router-link-active router-link-exact-active sidebar-item" aria-label="优势3:提交记录原子化"><!--[--><!--]--> 优势3:提交记录原子化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue3/01.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5-monorepo.html#优势4-便于大规模代码重构" class="router-link-active router-link-exact-active sidebar-item" aria-label="优势4:便于大规模代码重构"><!--[--><!--]--> 优势4:便于大规模代码重构 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue3/01.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5-monorepo.html#优势5-便于跨团队协作" class="router-link-active router-link-exact-active sidebar-item" aria-label="优势5:便于跨团队协作"><!--[--><!--]--> 优势5:便于跨团队协作 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue3/01.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5-monorepo.html#小结" class="router-link-active router-link-exact-active sidebar-item" aria-label="小结"><!--[--><!--]--> 小结 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/vue3/01.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5-monorepo.html#monorepo有什么缺陷" class="router-link-active router-link-exact-active sidebar-item" aria-label="monorepo有什么缺陷"><!--[--><!--]--> monorepo有什么缺陷 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vue3/01.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5-monorepo.html#丢失了版本信息" class="router-link-active router-link-exact-active sidebar-item" aria-label="丢失了版本信息"><!--[--><!--]--> 丢失了版本信息 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue3/01.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5-monorepo.html#失去了对每个项目的访问权限控制" class="router-link-active router-link-exact-active sidebar-item" aria-label="失去了对每个项目的访问权限控制"><!--[--><!--]--> 失去了对每个项目的访问权限控制 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue3/01.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5-monorepo.html#默认需要更大的存储空间" class="router-link-active router-link-exact-active sidebar-item" aria-label="默认需要更大的存储空间"><!--[--><!--]--> 默认需要更大的存储空间 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue3/01.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5-monorepo.html#其他缺陷" class="router-link-active router-link-exact-active sidebar-item" aria-label="其他缺陷"><!--[--><!--]--> 其他缺陷 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue3/01.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5-monorepo.html#小结-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="小结"><!--[--><!--]--> 小结 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/vue3/01.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5-monorepo.html#方式1-手动管理" class="router-link-active router-link-exact-active sidebar-item" aria-label="方式1:手动管理"><!--[--><!--]--> 方式1:手动管理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue3/01.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5-monorepo.html#方式2-lerna-npm" class="router-link-active router-link-exact-active sidebar-item" aria-label="方式2: lerna + npm"><!--[--><!--]--> 方式2: lerna + npm <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue3/01.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5-monorepo.html#方式3-lerna-yarn" class="router-link-active router-link-exact-active sidebar-item" aria-label="方式3: lerna + yarn"><!--[--><!--]--> 方式3: lerna + yarn <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue3/01.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5-monorepo.html#方式4-yarn-workspaces" class="router-link-active router-link-exact-active sidebar-item" aria-label="方式4: yarn workspaces"><!--[--><!--]--> 方式4: yarn workspaces <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue3/01.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5-monorepo.html#方式5-lerna-yarn-workspace" class="router-link-active router-link-exact-active sidebar-item" aria-label="方式5: lerna + yarn workspace"><!--[--><!--]--> 方式5: lerna + yarn workspace <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue3/01.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5-monorepo.html#方式6-pnpm-workspace" class="router-link-active router-link-exact-active sidebar-item" aria-label="方式6: pnpm workspace"><!--[--><!--]--> 方式6: pnpm workspace <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue3/01.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5-monorepo.html#写在最后" class="router-link-active router-link-exact-active sidebar-item" aria-label="写在最后"><!--[--><!--]--> 写在最后 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/vue3/02.%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%92%8C%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95.html" class="sidebar-item" aria-label="02.项目构建流程和源码调试方法"><!--[--><!--]--> 02.项目构建流程和源码调试方法 <!--[--><!--]--></a><!----></li><li><a href="/vue3/03.Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.html" class="sidebar-item" aria-label="03.Vue3响应式核心原理"><!--[--><!--]--> 03.Vue3响应式核心原理 <!--[--><!--]--></a><!----></li><li><a href="/vue3/04.Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B01.html" class="sidebar-item" aria-label="04.Vue3响应式系统源码实现1"><!--[--><!--]--> 04.Vue3响应式系统源码实现1 <!--[--><!--]--></a><!----></li><li><a href="/vue3/05.Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B02.html" class="sidebar-item" aria-label="05.Vue3响应式系统源码实现2"><!--[--><!--]--> 05.Vue3响应式系统源码实现2 <!--[--><!--]--></a><!----></li><li><a href="/vue3/06.reactive%E3%80%81ref%E7%9B%B8%E5%85%B3api%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0.html" class="sidebar-item" aria-label="06.reactive、ref相关api源码实现"><!--[--><!--]--> 06.reactive、ref相关api源码实现 <!--[--><!--]--></a><!----></li><li><a href="/vue3/07.%E6%95%85%E4%BA%8B%E8%A6%81%E4%BB%8EcreateApp%E8%AE%B2%E8%B5%B7.html" class="sidebar-item" aria-label="07.故事要从createApp讲起"><!--[--><!--]--> 07.故事要从createApp讲起 <!--[--><!--]--></a><!----></li><li><a href="/vue3/08.%E8%99%9A%E6%8B%9FNode%E5%88%B0%E7%9C%9F%E5%AE%9ENode%E7%9A%84%E8%B7%AF%E5%85%B6%E5%AE%9E%E5%BE%88%E9%95%BF.html" class="sidebar-item" aria-label="08.虚拟Node到真实Node的路其实很长"><!--[--><!--]--> 08.虚拟Node到真实Node的路其实很长 <!--[--><!--]--></a><!----></li><li><a href="/vue3/09.%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B.html" class="sidebar-item" aria-label="09.组件渲染和更新流程"><!--[--><!--]--> 09.组件渲染和更新流程 <!--[--><!--]--></a><!----></li><li><a href="/vue3/10.%E5%90%8D%E5%8A%A8%E6%B1%9F%E6%B9%96%E7%9A%84diff%E7%AE%97%E6%B3%95.html" class="sidebar-item" aria-label="10.名动江湖的diff算法"><!--[--><!--]--> 10.名动江湖的diff算法 <!--[--><!--]--></a><!----></li><li><a href="/vue3/11.%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E4%B9%8BBlock%20Tree%20%E4%B8%8E%20PatchFlags.html" class="sidebar-item" aria-label="11.编译优化之Block Tree 与 PatchFlags"><!--[--><!--]--> 11.编译优化之Block Tree 与 PatchFlags <!--[--><!--]--></a><!----></li><li><a href="/vue3/12.%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%86%E6%9E%90%E6%A8%A1%E7%89%88AST%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B.html" class="sidebar-item" aria-label="12.编译过程介绍及分析模版AST的生成过程"><!--[--><!--]--> 12.编译过程介绍及分析模版AST的生成过程 <!--[--><!--]--></a><!----></li><li><a href="/vue3/13.%E4%BB%8EAST%E5%88%B0render%E5%87%BD%E6%95%B0%EF%BC%88transform%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%EF%BC%89.html" class="sidebar-item" aria-label="13.从AST到render函数（transform与代码生成）"><!--[--><!--]--> 13.从AST到render函数（transform与代码生成） <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="_01-代码管理策略-monorepo" tabindex="-1"><a class="header-anchor" href="#_01-代码管理策略-monorepo" aria-hidden="true">#</a> 01.代码管理策略-monorepo</h1><blockquote><p><code>Vue3</code>采用了<code>monorepo</code>的方式来对项目代码进行管理。本文首先会介绍<code>monorepo</code>的一些基础知识，接着会介绍几种实现<code>monorepo</code>策略的具体方案，最后再进入<code>Vue3</code>的源码中了解其采取的具体方案和实施细节。</p></blockquote><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token doc-comment comment">/******************************************************************/</span>
<span class="token doc-comment comment">/*****************     欢迎关注微信公众号：杨艺韬     *****************/</span>
<span class="token doc-comment comment">/******************************************************************/</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="基础知识" tabindex="-1"><a class="header-anchor" href="#基础知识" aria-hidden="true">#</a> 基础知识</h1><h2 id="monorepo是什么" tabindex="-1"><a class="header-anchor" href="#monorepo是什么" aria-hidden="true">#</a> monorepo是什么</h2><p>我们先看看维基百科是怎么给<code>monorepo</code>定义的：</p><blockquote><p>In version control systems, a <code>monorepo</code> (&quot;mono&quot; meaning &#39;single&#39; and &quot;repo&quot; being short for &#39;repository&#39;) <code>is a</code> software development <code>strategy</code> where code for many projects is stored in the same repository.</p></blockquote><p>从定义中可以知道，<code>monorepo</code>是一种策略，该策略的具体内容是：<strong>多个项目存储在同一个代码仓库中</strong>。采用一种策略，肯定是因为该策略具备一些优点。当然，也要认清其缺点。从下面这张图中，我们可以看出，项目代码的组织策略是在实践中诞生，不断发展变化的。 <img src="/assets/01-01.e8270574.webp" alt="monorepo.jpeg"></p><p>在软件开发实践过程中，最初采用的代码组织策略很简单，不管有多少代码都放在一个项目中进行管理，这也就是单项目单仓库的策略，对应图中的<code>monolith</code>。随着时间的流逝，代码量多到一定程度的时候，会发现每一次构建都会花费很长时间，代码耦合度强可维护性差，代码冲突频繁等各种问题逐渐显现且愈加严重。于是聪明的工程师们，将业务相对独立的功能以不同的项目进行维护，对应图中的<code>multi repo</code>。这样确实解决了一些问题，比如项目自治，可维护性变强。但是也有一些新的问题出现，比如：</p><ul><li>项目不同但相关联的功能联合调试困难，项目<code>A</code>想要调用项目<code>B</code>的能力，只能安装<code>B</code>发布的包进行依赖，所依赖的项目代码发生变化后也无法及时做出响应；</li><li>如果一个功能涉及到<code>A</code>和<code>B</code>两个项目，但因为项目在各自的仓库中维护，代码提交记录都无法完整反映出一个功能相关的所有代码；</li><li>效率低下，每个项目都需要独立配置相关项目环境，独立进行安装依赖、启动项目、版本发布等操作。</li></ul><p>问题的出现，意味着问题的解决方案也快出现，<code>monorepo</code>就在工程师们感到头疼的时候诞生了。需要提示大家，<code>monorepo</code>作为一种代码管理策略，并不是新生事物，已经有20年以上的历史了，最初这种策略的名字叫<code>shared codebase</code>，只不过以<code>monorepo</code>这个称呼闻名于世。我们接下来就看看<code>monorepo</code>有什么优势和缺陷。</p><h2 id="monorepo有什么优势" tabindex="-1"><a class="header-anchor" href="#monorepo有什么优势" aria-hidden="true">#</a> monorepo有什么优势</h2><h3 id="优势1-重用代码更加容易" tabindex="-1"><a class="header-anchor" href="#优势1-重用代码更加容易" aria-hidden="true">#</a> 优势1:重用代码更加容易</h3><p>相似的功能可以抽取到一个单独的项目中进行维护，并且不需要借助依赖包管理器就可以在其所在仓库下的其他项目中进行引用。</p><h3 id="优势2-简化依赖管理" tabindex="-1"><a class="header-anchor" href="#优势2-简化依赖管理" aria-hidden="true">#</a> 优势2:简化依赖管理</h3><p>在<code>multi repo</code>策略下，对于不同的项目，相同的三方依赖库可能需要各自进行下载、构建，重复工作。而在<code>monorepo</code>策略中，所有的依赖项都存放在同一个地方，这不仅方便管理，还可以进行很多优化。</p><h3 id="优势3-提交记录原子化" tabindex="-1"><a class="header-anchor" href="#优势3-提交记录原子化" aria-hidden="true">#</a> 优势3:提交记录原子化</h3><p>由于是单个仓库对代码进行维护管理，那一次改动无论涉及几个项目，都能在当次提交记录中完整反映出来。比如一个功能需要改动两个项目，如果是两个仓库来维护这两个项目，那么追溯该功能所对应修改的代码，就显得很困难。</p><h3 id="优势4-便于大规模代码重构" tabindex="-1"><a class="header-anchor" href="#优势4-便于大规模代码重构" aria-hidden="true">#</a> 优势4:便于大规模代码重构</h3><p>开发者可以访问仓库下的所有项目，对某个项目进行重构的时候，可以保证该项目重构后和其他项目组合在一起是可以正常运行的。反之如果开发者独立维护一个项目，对该项目重构后，是不是能在整个系统中正常运转很难去验证。</p><h3 id="优势5-便于跨团队协作" tabindex="-1"><a class="header-anchor" href="#优势5-便于跨团队协作" aria-hidden="true">#</a> 优势5:便于跨团队协作</h3><p>比如团队<code>A</code>维护项目<strong>一</strong>，而团队<code>B</code>用到了项目<strong>一</strong>提供的能力，因为代码共享，可以及时跟踪项目<strong>一</strong>中的具体代码，甚至对该项目中的代码提供改进意见。</p><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h3><p>上面列出了<code>monorepo</code>的几个优势，对于我们实际开发来讲，优势<strong>1</strong>、<strong>2</strong>、<strong>3</strong>，显得更加重要。至于优势<strong>4</strong>、<strong>5</strong>可能在其他团队会发挥比较大的作用，笔者的实践经历中没有明显的体会。同时，优势<strong>3</strong>、<strong>4</strong>、<strong>5</strong>都是单仓库天然的作用，没有太多内容可以讨论。而优势<strong>1</strong>和<strong>2</strong>在下文会有较多内容涉及到。</p><h2 id="monorepo有什么缺陷" tabindex="-1"><a class="header-anchor" href="#monorepo有什么缺陷" aria-hidden="true">#</a> monorepo有什么缺陷</h2><h3 id="丢失了版本信息" tabindex="-1"><a class="header-anchor" href="#丢失了版本信息" aria-hidden="true">#</a> 丢失了版本信息</h3><p>有些采用<code>monorepo</code>策略进行管理的代码，在构建的时候对仓库中所有的项目采用同一个版本号，这样导致每个项目自身丢失了符合语义的版本号。比如我在<code>vue3</code>中看仓库中的每个版本号也确实是一致的。</p><h3 id="失去了对每个项目的访问权限控制" tabindex="-1"><a class="header-anchor" href="#失去了对每个项目的访问权限控制" aria-hidden="true">#</a> 失去了对每个项目的访问权限控制</h3><p>如果每个项目存放在单独的仓库，控制仓库权限就可以控制项目的访问权限。但在<code>monorepo</code>的策略下，多个项目的代码存放在同一个仓库中，难以对权限进行控制。当然，一般来说版本控制工具可以对权限进行细致的控制，这个缺陷可以规避。</p><h3 id="默认需要更大的存储空间" tabindex="-1"><a class="header-anchor" href="#默认需要更大的存储空间" aria-hidden="true">#</a> 默认需要更大的存储空间</h3><p>这一点很好理解，在<code>monorepo</code>的策略下，默认会下载该仓库下的所有项目的代码。虽然这可以通过版本控制工具的能力来弥补这个权限，但是又会削弱<code>monorepo</code>原本具备的优势。</p><h3 id="其他缺陷" tabindex="-1"><a class="header-anchor" href="#其他缺陷" aria-hidden="true">#</a> 其他缺陷</h3><p>比如代码规模大到一定程度，有海量频繁提交会触发<code>git</code>的能力瓶颈，导致无法正常工作。但鉴于普通企业普通项目，难以涉及这类特殊场景，本文就不做介绍了。</p><h3 id="小结-1" tabindex="-1"><a class="header-anchor" href="#小结-1" aria-hidden="true">#</a> 小结</h3><p>古人说用人用的是其长处，我们采用<code>monorepo</code>更多的是因为其自身的优点，后文不会再讨论其缺陷。</p><h1 id="管理monorepo类型项目的方案" tabindex="-1"><a class="header-anchor" href="#管理monorepo类型项目的方案" aria-hidden="true">#</a> 管理monorepo类型项目的方案</h1><p>上文解释过，<code>monorepo</code>是一种策略。理解这个概念很重要，因为刚接触<code>monorepo</code>的朋友容易把<code>monorepo</code>和某个具体的工具画上等号。比如存在下面的错误认识：&quot;monorepo就是yarn提供的workspace&quot;、&quot;monorepo就是yarn和lerna的组合&quot;等等。<code>monorepo</code>是一个策略，是一种思想，而不是一个具体的工具。基于这个认识，我们就不难理解将一个策略落地，可以有多种方案。而本文将会由不断将方案进行增强演进，最终得出两个管理<code>monorepo</code>类型项目的优良方案。</p><h2 id="方式1-手动管理" tabindex="-1"><a class="header-anchor" href="#方式1-手动管理" aria-hidden="true">#</a> 方式1:手动管理</h2><p>事实上实现<code>monorepo</code>策略，并不一定要借助额外的工具。那没有工具我们该具体怎么做呢？在行动之前我们要把握住<code>monorepo</code>一个核心要点，一个明显特征。核心要点是：<strong>多个项目存放在同一个代码仓库中</strong>。明显特征是：<strong>项目可以引用其仓库下其他项目的代码</strong>。 假设我们有三个拥有独立仓库的项目<code>A、B、C</code>，改造成以<code>monorepo</code>方式进行管理。改造后的项目结构如下：</p><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token list punctuation">-</span> root
    <span class="token list punctuation">-</span> package.json
    <span class="token list punctuation">-</span> projects
        <span class="token list punctuation">-</span> projectA
            <span class="token list punctuation">-</span> package.json
            <span class="token list punctuation">-</span> src
                <span class="token list punctuation">-</span> index.js
        <span class="token list punctuation">-</span> projectB
            <span class="token list punctuation">-</span> package.json
            <span class="token list punctuation">-</span> src
                <span class="token list punctuation">-</span> index.js
        <span class="token list punctuation">-</span> projectC
            <span class="token list punctuation">-</span> package.json
            <span class="token list punctuation">-</span> src
                <span class="token list punctuation">-</span> index.js
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假设这三个项目的职责如下：</p><ul><li>projectA: 一个依赖库，供其他项目访问</li><li>projectB: 一个<code>API</code>程序，启动后访问其监听的端口可以获取数据</li><li>projectC: 一个<code>H5</code>页面，需要使用<code>projectA</code>提供的功能，需要访问<code>projectB</code>提供的<code>API</code></li></ul><p>在实际开发中，可能会逐一执行形如下面的命令行：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">cd</span> projects/projectA
$ <span class="token function">npm</span> <span class="token function">install</span>
$ <span class="token function">npm</span> build
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">cd</span> projects/projectB
$ <span class="token function">npm</span> <span class="token function">install</span>
$ <span class="token function">npm</span> serve <span class="token comment"># 启动api服务项目</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">cd</span> projects/projectC
$ <span class="token function">npm</span> <span class="token function">install</span>
$ <span class="token function">npm</span> start <span class="token comment"># 启动H5页面项目</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外在<code>projectB</code>的<code>package.json</code>可能会有下面的配置：</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token punctuation">{</span>
 <span class="token comment">// 此处省略许多内容...</span>
 <span class="token property">&quot;dependencies&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;vue&quot;</span><span class="token operator">:</span> <span class="token string">&quot;^2.5.17&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;@monorepo/A&quot;</span><span class="token operator">:</span> <span class="token string">&quot;一个可以访问到projectA构建结果文件的相对路径&quot;</span>  <span class="token comment">// &quot;@monorepo/A&quot;是projectA中的package.json配置的name属性值</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 此处省略许多内容...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一系列手动操作，完成了<strong>3</strong>项工作：</p><ul><li>多个项目在同一个仓库下进行管理；</li><li>安装各个项目的依赖包，并启动各项目；</li><li>让<code>projectB</code>可以访问其所在仓库下的<code>projectA</code>的代码；</li></ul><p>可以直观的感受到，要想让这个系统正常运行，需要我们重复的手动执行一系列命令。这种方式很落后，但不可否认，这确实是一个<code>monorepo</code>类型项目的管理方案。</p><h2 id="方式2-lerna-npm" tabindex="-1"><a class="header-anchor" href="#方式2-lerna-npm" aria-hidden="true">#</a> 方式2: lerna + npm</h2><p>既然手动管理<code>monorepo</code>项目如上文描述的那般笨拙，那管理<code>monorepo</code>类型项目的工具也就诞生了，而<code>lerna</code>就是其中的佼佼者。<code>lerna</code>是什么呢？看官方文档是这样描述的：</p><blockquote><p>Lerna is a tool that optimizes the workflow around managing multi-package repositories with git and npm.</p></blockquote><p>可以理解为这是一个为了<code>monorepo</code>而生的工具。我们可以看<code>lerna</code>的两个重要的命令：</p><ul><li><code>lerna bootstrap</code> will link dependencies in the repo together.</li><li><code>lerna publish</code> will help publish any updated packages.</li></ul><p>可以看出<code>lerna pulish</code>命令是和版本发布相关的。<code>lerna bootstrap</code>主要完成了这么一项工作：进入所有的项目（如上文中<code>projectA、projectB、projectC</code>）目录，执行<code>npm install</code>命令安装依赖包。注意，在这里我们会发现，<code>lerna</code>会在每个子项目的根路径下面创建一个<code>node_modules</code>目录。</p><p>刚才讲了<code>lerna boostrap</code>这个命令的功能，下面简要介绍下如何配置<code>lerna</code>。</p><ul><li>在根目录下新建一个<code>lerna.json</code>文件，按照惯例<code>lerna</code>默认使用的是<code>npm</code>。也就是说可以省略配置项<code>&quot;npmClient&quot;: &quot;npm&quot;</code>。</li><li><code>lerna.json</code>中添加下面一个配置项，以便于<code>lerna</code>知道该去哪里寻找仓库中的项目：</li></ul><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token punctuation">{</span>
    packages<span class="token operator">:</span><span class="token punctuation">[</span>
        <span class="token string">&quot;projects/*&quot;</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>在根项目<code>package.json</code>中应该有下面的配置，然后执行<code>npm run bootstrap</code>：</li></ul><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token punctuation">{</span>
    scripts<span class="token operator">:</span><span class="token punctuation">{</span>
        &#39;bootstrap&#39;<span class="token operator">:</span>&#39;lerna bootstrap&#39;
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>lerna</code>为什么默认配置不是<code>&quot;npmClient&quot;: &quot;yarn&quot;</code>呢？实际上<code>lerna</code>出现的时间甚至要早于<code>yarn</code>。</p></blockquote><p>做了相应配置，执行相应的命令后，最终的结果和我们在<strong>方式1</strong>中的结果几乎是一模一样的。</p><h2 id="方式3-lerna-yarn" tabindex="-1"><a class="header-anchor" href="#方式3-lerna-yarn" aria-hidden="true">#</a> 方式3: lerna + yarn</h2><p>方式<strong>3</strong>和方式<strong>2</strong>相比很相似。不同的是，在<code>lerna.json</code>文件中需要将<code>npmClient</code>的值变更为<code>yarn</code>。既然<code>lerna</code>和<code>npm</code>结合或者<code>yarn</code>结合实现的功能是如此的相似，那我们如何选择呢？可以问问自己下面两个问题：</p><ul><li>自己是喜欢坚持行业标准呢还是喜欢Facebook提供的各种新特性？</li><li>是否真的关心安装依赖包的时间长短？ 事实上，不管选哪一个差别都不会太大，按自己感觉来就行。</li></ul><h2 id="方式4-yarn-workspaces" tabindex="-1"><a class="header-anchor" href="#方式4-yarn-workspaces" aria-hidden="true">#</a> 方式4: yarn workspaces</h2><p>对于这种方式，我们不需要形如<code>lerna.json</code>的配置文件，因为<code>yarn workspaces</code>天然自带<code>monorepo</code>相关能力。虽然没有专用的配置文件，但需要在项目根路径下的<code>package.json</code>文件中做些配置，例如：</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token punctuation">{</span>
    workspaces<span class="token operator">:</span><span class="token punctuation">[</span>
        <span class="token string">&quot;projects/*&quot;</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样<code>yarn</code>后续就知道在哪里去寻找<code>workspace</code>，这里的<code>workspace</code>其实就是各个子项目。当我们在项目根目录执行命令<code>yarn install</code>（这里的<code>install</code>可以省略）的时候，各个子项目也会安装各自的依赖项。这里和<strong>方式1</strong>与<strong>方式2</strong>有一个巨大的不同，执行完<code>yarn install</code>命令，只会在项目根路径下创建<code>node_modules</code>目录，各个子项目并没有这样一个目录来存放各自的依赖包。所有的依赖项都提升到了根路径下。事实上，<strong>方式2</strong>中如果执行<code>lerna boostrap</code>命令的时候加上<code>-hoist</code>标志，那么子项目的依赖项也会进行提升到根路径下。</p><h2 id="方式5-lerna-yarn-workspace" tabindex="-1"><a class="header-anchor" href="#方式5-lerna-yarn-workspace" aria-hidden="true">#</a> 方式5: lerna + yarn workspace</h2><p>到了这里，大家可能会觉得奇怪，<code>yarn workspace</code>可以管理<code>monorepo</code>类型的项目，<code>lerna + npm/yarn</code>也可以管理<code>monorepo</code>类型的项目。为什么又将二者相结合起来呢？实际上，这里的<code>lerna</code>角色发生了变化，在<strong>方式2</strong>、<strong>方式3</strong>中，<code>lerna</code>需要执行<code>lerna boostrap</code>进入各个子项目安装相关依赖。而和<code>yarn workspaces</code>相结合的情况下，这些依赖管理的工作都交给了<code>yarn worksapces</code>。之所以使用<code>lerna</code>，是希望利用<code>lerna</code>提供的一些工具命令来优化对<code>monorepo</code>类型项目的管理，比如测试的时候，可以利用<code>lerna</code>选择性的执行某些命令。同时<code>lerna</code>还提供了诸如版本发布等可以优化开发体验的工具。具体怎么配置，有哪些命令，怎么使用这些命令，朋友们可以查阅相关文档，就不在本文赘述了。</p><h2 id="方式6-pnpm-workspace" tabindex="-1"><a class="header-anchor" href="#方式6-pnpm-workspace" aria-hidden="true">#</a> 方式6: pnpm workspace</h2><p><code>pnpm</code>作为一个比较新的工具，肯定是解决了旧工具中存在的一些问题。我们先看看<code>yarn</code>存在什么问题，<code>yarn</code>文档中有这样一段描述：</p><blockquote><p>Be careful when publishing packages in a workspace. If you are preparing your next release and you decided to use a new dependency but forgot to declare it in the package.json file, your tests might still pass locally if another package already downloaded that dependency into the workspace root. However, it will be broken for consumers that pull it from a registry, since the dependency list is now incomplete so they have no way to download the new dependency. Currently, there is no way to throw a warning in this scenario.</p></blockquote><p>大意是说，在子项目（<code>yarn</code>称之为<code>workspace</code>）中当引用了一个三方依赖，如果没在该<code>workspace</code>下声明这个依赖，可能程序还能顺利执行，因为这个依赖库可能在别的<code>workspace</code>中安装过，由于<code>yarn</code>提升了所有<code>workspace</code>的依赖库到根路径下的<code>node_modules</code>进行管理，所以会出现这种情况，并且<code>yarn</code>也说了，这问题解决不了。</p><p>当然<code>yarn</code>还有其他问题，本文就不一一阐述。这里只需要知道，<code>pnpm</code>是一个相对新的，性能比较优良的包管理工具。</p><p><code>pnpm</code>也有类似<code>yarn</code>的<code>workspace</code>机制。不过和<code>yarn</code>不同，<code>pnpm</code>也需要配置独有的配置文件。而在<code>Vue3</code>中，目前也采用的<code>pnpm</code>来进行包的管理。</p><h1 id="vue3代码组织方式" tabindex="-1"><a class="header-anchor" href="#vue3代码组织方式" aria-hidden="true">#</a> Vue3代码组织方式</h1><p>先看看<code>Vue3</code>的包依赖关系：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>                                    +---------------------+
                                    |                     |
                                    |  @vue/compiler-sfc  |
                                    |                     |
                                    +-----+--------+------+
                                          |        |
                                          v        v
                      +---------------------+    +----------------------+
                      |                     |    |                      |
        +------------&gt;|  @vue/compiler-dom  +---&gt;|  @vue/compiler-core  |
        |             |                     |    |                      |
   +----+----+        +---------------------+    +----------------------+
   |         |
   |   vue   |
   |         |
   +----+----+        +---------------------+    +----------------------+    +-------------------+
        |             |                     |    |                      |    |                   |
        +------------&gt;|  @vue/runtime-dom   +---&gt;|  @vue/runtime-core   +---&gt;|  @vue/reactivity  |
                      |                     |    |                      |    |                   |
                      +---------------------+    +----------------------+    +-------------------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>与之匹配的，跟<code>pnpm</code>管理<code>monorepo</code>项目相关的代码如下：</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token comment">// 所在文件：core/pnpm-workspace.yaml ，注：vue3目前的仓库名叫core</span>
packages<span class="token operator">:</span>
  - &#39;packages<span class="token comment">/*&#39;
</span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token comment">// 所在文件: core/package.json， 部分配置</span>
<span class="token punctuation">{</span>
    <span class="token property">&quot;devDependencies&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">&quot;@vue/reactivity&quot;</span><span class="token operator">:</span> <span class="token string">&quot;workspace:*&quot;</span><span class="token punctuation">,</span>
        <span class="token property">&quot;@vue/runtime-core&quot;</span><span class="token operator">:</span> <span class="token string">&quot;workspace:*&quot;</span><span class="token punctuation">,</span>
        <span class="token property">&quot;@vue/runtime-dom&quot;</span><span class="token operator">:</span> <span class="token string">&quot;workspace:*&quot;</span><span class="token punctuation">,</span>
        <span class="token property">&quot;vue&quot;</span><span class="token operator">:</span> <span class="token string">&quot;workspace:*&quot;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样带来的好处是，如<code>Vue3</code>文档描述的那样：</p><blockquote><p>The packages can import each other directly using their package names. Note that when importing a package, the name listed in its <code>package.json</code> should be used. Most of the time the <code>@vue/</code> prefix is needed: <code>import { h } from &#39;@vue/runtime-core</code>. This is made possible via several configurations:</p><ul><li>For TypeScript, <code>compilerOptions.paths</code> in <code>tsconfig.json</code></li><li>For Jest, <code>moduleNameMapper</code> in <code>jest.config.js</code></li><li>For plain Node.js, they are linked using <a href="https://pnpm.io/workspaces" target="_blank" rel="noopener noreferrer">PNPM Workspaces<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span></a>.</li></ul></blockquote><h1 id="小结-2" tabindex="-1"><a class="header-anchor" href="#小结-2" aria-hidden="true">#</a> 小结</h1><p>本文介绍了<code>monorepo</code>的基础概念。接着介绍了管理<code>monorepo</code>的几种方案，从原始的手动管理到<code>lerna + yarn</code> 、<code>pnpm</code>两种优良的管理方式。文末介绍了<code>Vue3</code>中关于<code>pnpm</code>管理<code>monorepo</code>类型项目的的相关配置。限于篇幅，文中并未从细节处系统性的去描述如何配置文件，如何执行命令，笔者后续会产出一系列的关于前端工具的文章，目前就先到这里。本文的目标是帮助大家理解<code>monorepo</code>的基本概念，知道日常开发中一些<code>monorepo</code>相关的工具的名称（<code>lerna、npm、yarn、yarn workspace、pnpm</code>）背后的含义和具备的能力，不会因为对<code>monorepo</code>认知的模糊而阻碍我们进入<code>Vue3</code>源码的世界，朋友们可以查阅文档了解这些工具的具体使用方式。下一篇文章，将会带着大家了解<code>Vue3</code>代码的构建流程。有了这些基础，我们才能在后续对<code>Vue3</code>源码进行顺利的调试，敬请朋友们期待。</p><p>参考资料：</p><ul><li>https://doppelmutzi.github.io/monorepo-lerna-yarn-workspaces/</li><li>https://pnpm.io/workspaces</li><li>https://yarnpkg.com/features/workspaces</li><li>https://lerna.js.org/</li></ul><h2 id="写在最后" tabindex="-1"><a class="header-anchor" href="#写在最后" aria-hidden="true">#</a> 写在最后</h2><p>读完文章觉得有收获的朋友们，可以做下面几件事情支持一下：</p><ul><li>如果您此刻在掘金看见这篇文章，辛苦<code>点赞</code>，增加掘力值，助我早日成为掘金优秀作者；</li><li>如果您此刻在微信公众号，请<code>点赞，点在看，转发</code>，让文章帮助到更多需要帮助的人；</li><li>如果是微信公众号的作者，可以找我开通<code>白名单</code>，<code>转载</code>我的原创文章；</li></ul><p>最后，请朋友们关注我的<code>微信公众号: 杨艺韬</code>，可以获取我的最新动态。</p></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">贡献者: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: yangyitao2@tal.com">yangyitao</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><!----><span class="next"><a href="/vue3/02.%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%92%8C%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95.html" class="" aria-label="02.项目构建流程和源码调试方法"><!--[--><!--]--> 02.项目构建流程和源码调试方法 <!--[--><!--]--></a></span></p></nav><!--[--><!--[--><div class="giscus-wrapper input-top" style="display:block;"><div style="text-align:center">Loading...</div></div><!-- <div style="width: 100%; text-align:center; margin-top: 60px; position: absolute; background: red">
        <a style="color:#a7a7a7; font-size:14px;" href="https://beian.miit.gov.cn">蜀ICP备2022025666号-1 &copy;杨艺韬</a>
      </div> --><!--]--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.4326c516.js" defer></script>
  </body>
</html>
